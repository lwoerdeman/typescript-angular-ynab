/**
 * YNAB API Endpoints
 * Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.youneedabudget.com
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CategoriesResponse } from '../model/categoriesResponse';
import { CategoryResponse } from '../model/categoryResponse';
import { ErrorResponse } from '../model/errorResponse';
import { SaveMonthCategoryWrapper } from '../model/saveMonthCategoryWrapper';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class CategoriesService {

    protected basePath = 'https://api.youneedabudget.com/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath || basePath || this.basePath;

        } else {
            this.configuration.basePath = basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * List categories
     * Returns all categories grouped by category group.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @param budgetId The id of the budget (\&quot;last-used\&quot; can also be used to specify the last used budget)
     * @param lastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCategories(budgetId: string, lastKnowledgeOfServer?: number, observe?: 'body', reportProgress?: boolean): Observable<CategoriesResponse>;
    public getCategories(budgetId: string, lastKnowledgeOfServer?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoriesResponse>>;
    public getCategories(budgetId: string, lastKnowledgeOfServer?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoriesResponse>>;
    public getCategories(budgetId: string, lastKnowledgeOfServer?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (budgetId === null || budgetId === undefined) {
            throw new Error('Required parameter budgetId was null or undefined when calling getCategories.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (lastKnowledgeOfServer !== undefined && lastKnowledgeOfServer !== null) {
            queryParameters = queryParameters.set('last_knowledge_of_server', <any>lastKnowledgeOfServer);
        }

        let headers = this.defaultHeaders;

        // authentication (bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CategoriesResponse>(`${this.configuration.basePath}/budgets/${encodeURIComponent(String(budgetId))}/categories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Single category
     * Returns a single category.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @param budgetId The id of the budget (\&quot;last-used\&quot; can also be used to specify the last used budget)
     * @param categoryId The id of the category
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCategoryById(budgetId: string, categoryId: string, observe?: 'body', reportProgress?: boolean): Observable<CategoryResponse>;
    public getCategoryById(budgetId: string, categoryId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoryResponse>>;
    public getCategoryById(budgetId: string, categoryId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoryResponse>>;
    public getCategoryById(budgetId: string, categoryId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (budgetId === null || budgetId === undefined) {
            throw new Error('Required parameter budgetId was null or undefined when calling getCategoryById.');
        }
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getCategoryById.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CategoryResponse>(`${this.configuration.basePath}/budgets/${encodeURIComponent(String(budgetId))}/categories/${encodeURIComponent(String(categoryId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Single category for a specific budget month
     * Returns a single category for a specific budget month.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
     * @param budgetId The id of the budget (\&quot;last-used\&quot; can also be used to specify the last used budget)
     * @param month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
     * @param categoryId The id of the category
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMonthCategoryById(budgetId: string, month: string, categoryId: string, observe?: 'body', reportProgress?: boolean): Observable<CategoryResponse>;
    public getMonthCategoryById(budgetId: string, month: string, categoryId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoryResponse>>;
    public getMonthCategoryById(budgetId: string, month: string, categoryId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoryResponse>>;
    public getMonthCategoryById(budgetId: string, month: string, categoryId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (budgetId === null || budgetId === undefined) {
            throw new Error('Required parameter budgetId was null or undefined when calling getMonthCategoryById.');
        }
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling getMonthCategoryById.');
        }
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getMonthCategoryById.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CategoryResponse>(`${this.configuration.basePath}/budgets/${encodeURIComponent(String(budgetId))}/months/${encodeURIComponent(String(month))}/categories/${encodeURIComponent(String(categoryId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a category for a specific month
     * Update a category for a specific month
     * @param budgetId The id of the budget (\&quot;last-used\&quot; can also be used to specify the last used budget)
     * @param month The budget month in ISO format (e.g. 2016-12-01) (\&quot;current\&quot; can also be used to specify the current calendar month (UTC))
     * @param categoryId The id of the category
     * @param data The category to update
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateMonthCategory(budgetId: string, month: string, categoryId: string, data: SaveMonthCategoryWrapper, observe?: 'body', reportProgress?: boolean): Observable<CategoryResponse>;
    public updateMonthCategory(budgetId: string, month: string, categoryId: string, data: SaveMonthCategoryWrapper, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CategoryResponse>>;
    public updateMonthCategory(budgetId: string, month: string, categoryId: string, data: SaveMonthCategoryWrapper, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CategoryResponse>>;
    public updateMonthCategory(budgetId: string, month: string, categoryId: string, data: SaveMonthCategoryWrapper, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (budgetId === null || budgetId === undefined) {
            throw new Error('Required parameter budgetId was null or undefined when calling updateMonthCategory.');
        }
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling updateMonthCategory.');
        }
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling updateMonthCategory.');
        }
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling updateMonthCategory.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<CategoryResponse>(`${this.configuration.basePath}/budgets/${encodeURIComponent(String(budgetId))}/months/${encodeURIComponent(String(month))}/categories/${encodeURIComponent(String(categoryId))}`,
            data,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
